// This file is @generated by prost-build.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct HelloMessage {
    #[prost(string, tag = "1")]
    pub message: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub wait_time: u32,
}
pub mod hello {
    use rums::Configuration;
    use futures::stream::Stream;
    use std::error::Error;
    use futures::stream::StreamExt;
    use prost::Message;
    use rums::ServerHandler;
    use rums::get_route;
    use rums::add_route;
    use rums::RouteHandler;
    use rums::Response;
    use std::marker::Copy;
    pub trait HelloClient<NIDT> {
        fn hello_world<'a>(
            &'a self,
            msg: &super::HelloMessage,
        ) -> impl Stream<Item = Response<'a, super::HelloMessage, NIDT>>
        where
            NIDT: 'a;
        fn goodbye_world<'a>(
            &'a self,
            msg: &super::HelloMessage,
        ) -> impl Stream<Item = Response<'a, super::HelloMessage, NIDT>>
        where
            NIDT: 'a;
    }
    impl<NIDT: Copy> HelloClient<NIDT> for Configuration<NIDT> {
        fn hello_world<'a>(
            &'a self,
            msg: &super::HelloMessage,
        ) -> impl Stream<Item = Response<'a, super::HelloMessage, NIDT>>
        where
            NIDT: 'a,
        {
            let mut buf = vec![];
            msg.encode(&mut buf).unwrap();
            let buf = add_route(
                add_route(add_route(buf, "HelloWorld"), "Hello"),
                "hello",
            );
            let responses = self.send(buf.into_boxed_slice());
            responses
                .map(|res| {
                    Response {
                        node: res.node,
                        response: res
                            .response
                            .map(|buf| {
                                super::HelloMessage::decode(&buf as &[u8]).unwrap()
                            }),
                    }
                })
        }
        fn goodbye_world<'a>(
            &'a self,
            msg: &super::HelloMessage,
        ) -> impl Stream<Item = Response<'a, super::HelloMessage, NIDT>>
        where
            NIDT: 'a,
        {
            let mut buf = vec![];
            msg.encode(&mut buf).unwrap();
            let buf = add_route(
                add_route(add_route(buf, "GoodbyeWorld"), "Hello"),
                "hello",
            );
            let responses = self.send(buf.into_boxed_slice());
            responses
                .map(|res| {
                    Response {
                        node: res.node,
                        response: res
                            .response
                            .map(|buf| {
                                super::HelloMessage::decode(&buf as &[u8]).unwrap()
                            }),
                    }
                })
        }
    }
    pub trait HelloServer {
        fn hello_world(
            &mut self,
            msg: super::HelloMessage,
        ) -> Result<super::HelloMessage, Box<dyn Error + Send>>;
        fn goodbye_world(
            &mut self,
            msg: super::HelloMessage,
        ) -> Result<super::HelloMessage, Box<dyn Error + Send>>;
    }
    pub struct HelloHandler {
        handlers: Box<dyn HelloServer + Send>,
    }
    impl HelloHandler {
        pub fn new(handlers: Box<dyn HelloServer + Send>) -> Self {
            Self { handlers: handlers }
        }
    }
    impl ServerHandler for HelloHandler {
        fn handle(
            &'_ mut self,
            request: &[u8],
        ) -> Result<Vec<u8>, Box<dyn Error + Send>> {
            let (request, route) = get_route(request);
            match route {
                "HelloWorld" => {
                    let msg = super::HelloMessage::decode(request).unwrap();
                    let rsp = self.handlers.hello_world(msg);
                    rsp.map(|msg| {
                        let mut buf = vec![];
                        msg.encode(&mut buf).unwrap();
                        buf
                    })
                }
                "GoodbyeWorld" => {
                    let msg = super::HelloMessage::decode(request).unwrap();
                    let rsp = self.handlers.goodbye_world(msg);
                    rsp.map(|msg| {
                        let mut buf = vec![];
                        msg.encode(&mut buf).unwrap();
                        buf
                    })
                }
                &_ => todo!(),
            }
        }
    }
    pub trait RegisterHelloHandler {
        fn register_hello_handler(&mut self, handler: Box<dyn ServerHandler + Send>);
    }
    impl RegisterHelloHandler for RouteHandler {
        fn register_hello_handler(&mut self, handler: Box<dyn ServerHandler + Send>) {
            self.sub_route("hello").add_route("Hello", handler);
        }
    }
}
